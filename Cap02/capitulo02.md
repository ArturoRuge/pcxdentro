##Representacion Numerica.

### 2.1.  Introduci√≥n.

*Desde hace tiempo el hombre en su vida diaria se expresa, comunica, almacenan informaci√≥n, la manipula, mediante letras y n√∫meros. Para la representaci√≥n num√©rica utiliza el sistema de representaci√≥n decimal, en tanto que, dependiendo del idioma, dispone de un alfabeto que representa estas letras. Siguiendo el mismo principio que gu√≠a al hombre, las computadoras tienen su propio sistema de representaci√≥n. Debido a su construcci√≥n basada fundamentalmente en circuitos electr√≥nicos digitales, utiliza un sistema binario. Esto obliga a transformar a la representaci√≥n binaria para que la maquina sea capaz de procesarlos.* 
Como veremos m√°s adelante, tanto el sistema decimal como el binario est√°n basados en los mismos principios. En ambos, la representaci√≥n de un numero se afect√∫a por medio de cadenas de s√≠mbolos, los cuales representan una determinada cantidad dependiendo de cada s√≠mbolo y la posici√≥n que ocupa dentro de la cadena con respecto al denominado punto (o coma) decimal.  *
*Por cuestiones de √≠ndole t√©cnica, los circuitos electr√≥nicos que conforman una computadora suelen estar capacitados para reconocer se√±ales el√©ctricas de tipo digital; por lo tanto, se hace necesario que los m√©todos de codificaci√≥n internos tengan su origen en el sistema binario, y con ellos se pueda representar todo tipo de informaciones y ordenes que sean manejadas por la computadora.*
 *En los circuitos electr√≥nicos suele representarse la presencia de tensi√≥n (electricidad) en un punto de un circuito por medio de un 1, en tanto que un 0 representa la ausencia de dicha tensi√≥n.*

## 2.2 Sistema de Numeracion

*Se denomina sistema de numeraci√≥n al conjunto de simbolos y reglas que se utilizan para la representacion de datos numericos o cantidades. Un sistema de numeracion se caracteriza fundamentalmente por su base, que es el numero de simbolos distintos que utiliza y ademas es el coeficiente que determina cual es el valor de cada simbolo dependiendo de la posicion que ocupe.*
*Los sistemas de numeracion actuales son sistemas posicionales, en los que el valor relativo que representa cada simbolo o cifra de una determinada cantidad depende de su valor absoluto y de la posicion relativa que ocupa dicha con respecto a la coma decimal.*
##2.2.1. Teorema fundamental de la numeraci√≥n
*Se trata de un teorema que relaciona una cantidad expresada en cualquier
sistema de numeraci√≥n posicional con la misma cantidad expresada en el sistema
decimal. Supongamos una cantidad expresada en un sistema cuya base es B y
representamos por xi cada uno de los d√≠gitos que contiene dicha cantidad, donde
el sub√≠ndice i indica la posici√≥n del d√≠gito con respecto a la coma fraccionaria,
la posici√≥n se numera en forma creciente hacia la izquierda y decreciente hacia
la derecha de la coma (posici√≥n 0), en ambos casos de a 1.
El Teorema Fundamental de la Numeraci√≥n dice que el valor decimal de una
cantidad expresada en otro sistema de numeraci√≥n, est√° dado por la f√≥rmula:
N√∫mero =
Xn
i=‚àím
(d√≠gitoi) √ó (base)
i
(2.1)
donde el n√∫mero en base B es . . . x4x3x2x1x0x‚àí1x‚àí2 . . . , o sea:
N√∫mero = x‚àím √ó B
‚àím + x‚àím+1 √ó B
‚àím+1 + ¬∑ ¬∑ ¬∑ +
+ x‚àí2 √ó B
‚àí2 + x‚àí1 √ó B
‚àí1 + x0 √ó B
0 + x1 √ó B
1 + x2 √ó B
2 + ¬∑ ¬∑ ¬∑ +
+ xn‚àí1 √ó B
n‚àí1 + xn √ó B
n
1 (2.2)*
##2.2.2. Sistemas decimal, binario y hexadecimal###
*El sistema que ha usado el hombre para contar desde hace bastante tiempo
es el denominado sistema decimal, adoptado por contar con los diez dedos de la
mano. El sistema decimal es uno de los denominados posicionales, que utiliza
un conjunto de 10 s√≠mbolos, xi0, 1, ..., 9. Un valor determinado o cantidad, que
se denomina n√∫mero decimal, se puede expresar por la f√≥rmula del Teorema 2.1,
donde la base es 10.*
###¬øCu√°l es la interpretaci√≥n de la representaci√≥n de la cantidad 3,1416?###
*Siguiendo el Teorema Fundamental de la Numeraci√≥n, utilizando la base 10,
resulta*:
3, 1416 = 3 √ó 100 + 1 √ó 10‚àí1 + 4 √ó 10‚àí2 + 1 √ó 10‚àí3 + 6 √ó 10‚àí4
(2.3)

*El sistema binario es el sistema de numeraci√≥n que utiliza internamente el
hardware de las computadoras actuales. La base o n√∫mero de s√≠mbolos que
utiliza el sistema binario es 2, siendo los s√≠mbolos 0 y 1, los utilizados para la
representaci√≥n de cantidades*.###¬øQu√© n√∫mero decimal representa el n√∫mero binario 1001,1?###
*Utilizando el Teorema Fundamental de la Numeraci√≥n*:
1001, 1(2 = 1 √ó 2
3 + 0 √ó 2
2 + 0 √ó 2
1 + 1 √ó 2
0 + 1 √ó 2
‚àí1
(2.4)

*Al igual que los anteriores, el sistema hexadecimal es un sistema posicional
pero que utiliza diecis√©is s√≠mbolos para la representaci√≥n de cantidades. Estos
s√≠mbolos son los siguientes: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E y F; donde las
letras A, B, C, D, E y F equivalen a 10, 11, 12, 13, 14 y 15 del sitema decimal
respectivamente*.

###¬øQu√© n√∫mero decimal representa el n√∫mero hexadecimal 2CA?###
*Siguiendo el Teorema Fundamental de la Numeraci√≥n:
2CA(16 = 2 √ó 162 + C √ó 161 + A √ó 160
(2.5)
2CA(16 = 2 √ó 162 + 12 √ó 161 + 10 √ó 160
(2.6)
2CA(16 = 512 + 192 + 10 = 714 (2.7)*

##2.2.3. Operaciones de Suma y Resta Binaria##
*Las operaciones aritm√©ticas son similares a las del sistema decimal, con la
diferencia que se manejan s√≥lo los d√≠gitos 0 y 1. Al realizar la suma parcial de
dos d√≠gitos, si el resultado excede el valor del m√°ximo d√≠gito (el 1) se debe pasar
el sobrante (denominado acarreo) a la suma parcial siguiente hacia la izquierda.
Sumemos los n√∫meros binarios 100100 y 10110*
1 ‚àí‚Üí carry
1 0 0 1 0 0
+ 1 0 1 1 0 =1 1 1 0 1 0

*En la resta binaria hay que tener en cuenta que al realizar las restas parciales
entre dos d√≠gitos de id√©nticas posiciones, uno del minuendo y otro del sustraendo,
si el segundo excede al primero, se sustrae una unidad del d√≠gito de m√°s a la
izquierda en el minuendo ‚Äìpedir prestado-. Si el d√≠gito siguiente de la izquierda
es 0, se busca en los sucesivos teniendo en cuenta que su valor se multiplica por
dos a cada desplazamiento sucesivo a derecha.
Restemos los n√∫meros binarios 111100 y 101010*
10 ‚àí‚Üí borrow
1 1 1 ‚úÅ1 ‚úÅ0 0
- 1 0 1 0 1 0 = 0 1 0 0 1 0##2.2.4. Conversiones entre los sistemas de numeraci√≥n##*Se denomina conversi√≥n entre n√∫meros representados en distintos sistemasde numeraci√≥n a la transformaci√≥n de una determinada cantidad expresada enuno de dichos sistemas de numeraci√≥n, a su representaci√≥n equivalente en el otrosistema.Conversi√≥n decimal-binarioEl m√©todo de conversi√≥n de un n√∫mero decimal a un n√∫mero binario consisteen efectuar, sobre la parte entera del n√∫mero decimal, divisiones sucesivas de loscocientes por el n√∫mero 2, hasta que el cociente entre una de las divisiones tomeel valor 0. La uni√≥n de todos los restos obtenidos, escritos en orden inverso, nosproporciona el n√∫mero inicial expresado en sistema binario*. ![](http://www.carlospes.com/curso_representacion_datos/imagenes/ejemplo_02_73_1.gif)**Figura 2.1**: *Convirtiendo el n√∫mero decimal 19 a binarioPara convertir una fracci√≥n decimal a su equivalente binario se debe multiplicardicha fracci√≥n por dos, obteniendo en la parte entera del resultado elprimero de los d√≠gitos binarios de la fracci√≥n que buscamos. A continuaci√≥n,se repite el proceso con la parte fraccionaria del resultado anterior, obteniendoen la parte entera del nuevo resultado el segundo de los d√≠gitos buscados. Elproceso se repite hasta que desaparezca la parte fraccionaria de los resultadosparciales (se haga 0) o hasta que tengamos los suficientes d√≠gitos binarios*.0, 828125 √ó2 = 1, 656250, 65625 √ó2 = 1, 31250, 3125 √ó2 = 0, 6250, 625 √ó2 = 1, 250, 25 √ó2 = 0, 50, 5 √ó2 = 10, 828125(10 = 0, 110101(2***Figura 2.2**: Convirtiendo el n√∫mero decimal 0,828125 a binarioConversi√≥n hexadecimal-binario y viceversaPara convertir un n√∫mero hexadecimal a binario se sustituye cada d√≠gitohexadecimal por su representaci√≥n binaria con cuatro d√≠gitos seg√∫n el Cuadro 2.1***Hexadecimal Binario**![](http://4.bp.blogspot.com/_9fqFNLzPrtk/SicgckxUvXI/AAAAAAAAABk/f9KuH47Gv9U/s320/Tabla+Hex-Dec-Bin.png)**Cuadro 2.1**: Tabla de conversi√≥n **Hexadecimal-Binario***En tanto que la conversi√≥n binaria hexadecimal se realiza un proceso inverso.Se agrupan los d√≠gitos binario de a 4 a partir del punto decimal hacia la izquierday hacia la derecha, sustituyendo cada cuarteto por su correspondiente d√≠gitohexadecimal*.**Convertimos el n√∫mero hexadecimal 7BA3,BC a binario**7........ B........A..... 3 ,.......B..... C0111 1011 1010 0111 , 1011 1100*Entonces luego de la conversi√≥n, escribimos el n√∫mero. Omitimos los 0 no significativos*:7BA3, BC(16 = 111101110100111, 101111(2**Convertimos el n√∫mero binario 110010100100,1011011 a hexadecimal***Completamos con 0 para obtener los cuartetos necesarios para la conversi√≥n.Realizamos la conversi√≥n inmediata utilizando el cuadro 2.1.*0001 1001 0100 1000 , 1011 0110 ---1-----9------ 4----- 8 , ----B----- 6Finalmente resulta: 1100101001000, 1011011(2 = 1948, B6(16**Conversi√≥n de cualquier base a decimal***Para ello se utiliza el teorema fundamental de la numeraci√≥n y se convierteel n√∫mero de la base que se disponga a la decimal.*##2.3. Representaci√≥n de n√∫meros enteros##*Las computadoras utilizan cuatro m√©todos para la representaci√≥n interna den√∫meros enteros (positivos y negativos)*:M√≥dulo y signoComplemento a 1Complemento a 2Exceso a 2n‚àí1*Estas representaciones de n√∫meros utilizan el sistema binario y siempre seconsidera que tenemos un n√∫mero limitado de bits para cada dato. Este n√∫merode bits disponibles lo representamos generalmente con la letra n. Tambi√©n sepueden representar mediante estos m√©todos n√∫meros reales, como veremos m√°sadelante.Al tener una cantidad limitada de bits para representar, vamos a estar limitadosen la cantidad de n√∫meros que podemos representar. Se denomina rangode representaci√≥n en un m√©todo determinado al conjunto de n√∫mero representablesen el mismo*.##2.3.1. M√≥dulo y signo##*En este sistema de representaci√≥n, el bit que est√° situado m√°s a la izquierda(bit m√°s significativo, MSB, most significant bit en ingl√©s) representa el signo, ysu valor ser√° 0 para el signo positivo (+) y 1 para el signo negativo (‚àí). Los bitsrestantes (n‚àí1) representan el m√≥dulo del n√∫mero. Suponemos en principio quelos n√∫meros no poseen parte decimal, por lo que la coma se supone impl√≠cita ala derecha.Por ejemplo, supongamos que disponemos de n = 8 bits, y queremos representarlos n√∫meros 10 y ‚àí10. Veamos cuales son sus representaciones.*(0 es positivo +) 0 0 0 1 0 1 0m√≥dulo = 10**Figura 2.3**: Representaci√≥n del n√∫mero 10.(1 es negativo -) 0 0 0 1 0 1 0 m√≥dulo = -10**Figura 2.4**: Representaci√≥n del n√∫mero -10.**Rango***Para m√≥dulo y signo el rango de representaci√≥n de una palabra de n bitsest√° determinado por*:‚àí2n‚àí1 + 1 ‚â§ Rango ‚â§ 2n‚àí1 ‚àí 1 (2.8).En el caso de n = 8 bits, el rango de representaci√≥n va desde ‚àí127 a 127.La ventaja que presenta este sistema frente a otros es la de poseer un rangosim√©trico (igual cantidad de n√∫meros positivos que negativos). Mientras que sumayor inconveniente es el de poseer dos representaciones para el n√∫mero 0. Elcual se representa tanto con un signo positivo (0) como con uno negativo (1) yel resto de los bits en 0.2.3.2. Complemento a 1En este sistema de representaci√≥n tambi√©n el bit de m√°s a la izquierda seinterpreta como el signo, correspondiendo el 0 para el signo positivo (+) y el1 para el signo negativo (‚àí). Para los n√∫meros positivos, los n ‚àí 1 bits de laderecha representan el m√≥dulo (igual que en el sistema anterior). El negativo deun n√∫mero positivo se obtiene complementando todos sus d√≠gitos (cambiandoceros por uno y viceversa) incluido el signo.Veamos la representaci√≥n en complemento a 1 de los n√∫meros 10 y ‚àí10 parael caso de n = 8 bits.0 0 0 0 1 0 1 0+ m√≥dulo = 10Figura 2.5: Representaci√≥n del n√∫mero 10.1 1 1 1 0 1 0 1- m√≥dulo = 117Figura 2.6: Representaci√≥n del n√∫mero -10.RangoPara el complemento a 1 el rango de representaci√≥n de n bits:‚àí2n‚àí1 + 1 ‚â§ Rango ‚â§ 2n‚àí1 ‚àí 1 (2.9)*En el caso de n = 8 bits, el rango de representaci√≥n va desde ‚àí127 a 127.La ventaja que presenta este sistema frente a otros es la de poseer un rangosim√©trico (igual cantidad de n√∫meros positivos que negativos). Mientras que sumayor inconveniente es el de poseer dos representaciones para el n√∫mero 0. Elcual se representa tanto con un signo positivo con todos sus bits en cero (0), ycon signo negativo, con todos los bits en 1*.##2.3.2. Complemento a 1##En este sistema de representaci√≥n tambi√©n el bit de m√°s a la izquierda seinterpreta como el signo, correspondiendo el 0 para el signo positivo (+) y el1 para el signo negativo (‚àí). Para los n√∫meros positivos, los n ‚àí 1 bits de laderecha representan el m√≥dulo (igual que en el sistema anterior). El negativo deun n√∫mero positivo se obtiene complementando todos sus d√≠gitos (cambiandoceros por uno y viceversa) incluido el signo.Veamos la representaci√≥n en complemento a 1 de los n√∫meros 10 y ‚àí10 parael caso de n = 8 bits.(0+) 0 0 0 1 0 1 0 m√≥dulo = 10**Figura 2.5**: Representaci√≥n del n√∫mero 10.(1-)1 1 1 0 1 0 1 m√≥dulo = 117**Figura 2.6:** Representaci√≥n del n√∫mero -10.**Rango***Para el complemento a 1 el rango de representaci√≥n de n bits:‚àí2n‚àí1 + 1 ‚â§ Rango ‚â§ 2n‚àí1 ‚àí 1 (2.9)En el caso de n = 8 bits, el rango de representaci√≥n va desde ‚àí127 a 127.La ventaja que presenta este sistema frente a otros es la de poseer un rangosim√©trico (igual cantidad de n√∫meros positivos que negativos). Mientras que sumayor inconveniente es el de poseer dos representaciones para el n√∫mero 0. Elcual se representa tanto con un signo positivo con todos sus bits en cero (0), y*##2.3.3. Complemento a 2##*Al igual que los anteriores, este sistema de representaci√≥n interpreta el bitde m√°s a la izquierda como el signo, correspondiendo el 0 para el signo positivo(+) y el 1 para el signo negativo (‚àí). Para los n√∫meros positivos, los restantes(n ‚àí 1) bits de la derecha representan el m√≥dulo (igual que en los dos sistemasanteriores). El negativo de un n√∫mero positivo se obtiene en dos pasos:1- Se complementa el n√∫mero positivo en todos sus bits (cambiando ceros poruno y viceversa), incluido el bit de signo. Es decir se hace el complementoa 1.*2- Al resultado obtenido se le suma 1 (en binario), despreciando el √∫ltimoacarreo si existiera.Veamos la representaci√≥n en complemento a 2 de los n√∫meros 10 y ‚àí10 parael caso de n = 8 bits.(0+) 0 0 0 1 0 1 0 m√≥dulo = 10**Figura 2.7**: Representaci√≥n del n√∫mero 10.(1-) 1 1 1 0 1 1 0 m√≥dulo = 118**Figura 2.8:** Representaci√≥n del n√∫mero -10.**Rango**Para el complemento a 2 el rango de representaci√≥n de n bits:‚àí2n‚àí1 ‚â§ Rango ‚â§ 2n‚àí1 ‚àí 1 (2.10)*Para el caso de n = 8 bits, el rango de representaci√≥n va desde ‚àí128 a 127.La principal ventaja es la de tener una √∫nica representaci√≥n para el n√∫mero 0.Como principal desventaja de este sistema es que el rango de representaci√≥n den√∫meros no es sim√©trico.*##2.3.4. Exceso a 2 n-1##*Este m√©todo de representaci√≥n no utiliza la convenci√≥n del bit m√°s significativopara identificar el signo, con lo cual todos los bits representan un n√∫mero ovalor. Este valor se corresponde con el n√∫mero representado m√°s el exceso, quepara n bits viene dado por 2n‚àí1*. *El signo del n√∫mero resulta de una operaci√≥naritm√©tica. Por ejemplo, para n = 8 bits el exceso ser√° 128, con lo cual para representarun n√∫mero deber√° sum√°rsele dicho exceso. De esta manera el n√∫mero10, que ven√≠amos representando, recibir√° la adici√≥n del n√∫mero 128, con lo querepresentaremos el n√∫mero decimal 138 en binario. Por otro lado, el n√∫mero 10,se representar√° como el n√∫mero decimal 118 en binario (‚àí10 + 128)*. De estaforma quedar√°n:(1+) 0 0 0 1 0 1 0 m√≥dulo = 138**Figura 2.9**: Representaci√≥n del n√∫mero 10.(0-) 1 1 1 0 1 1 0 m√≥dulo = 118**Figura 2.10**: Representaci√≥n del n√∫mero -10.**Rango**El rango de representaci√≥n en exceso a 2n‚àí1 viene dado por:‚àí2n‚àí1 ‚â§ Rango ‚â§ 2n‚àí1 ‚àí 1 (2.11)*La principal ventaja de este sistema de representaci√≥n resulta que tiene una√∫nica forma de representar el cero (0). Mientras que su principal desventaja esque el rango resulta asim√©trico. La representaci√≥n del 0 consiste en representarel exceso, por ejemplo 128 para 8 bits.Resulta interesante observar que todo n√∫mero representado en exceso a 2n‚àí1tiene la misma representaci√≥n que un complemento a 2 con el bit de signocambiado. Podr√≠a decirse entonces, que el bit mas significativo representar√≠a elsigno pero esta vez utilizando el 0 para el signo positivo (+) y el 1 para el signonegativo (‚àí).La representaci√≥n en exceso a 2n‚àí1es simplemente desplazar el cero de sulugar, a donde est√° el exceso.*#2.3.5. Suma en complemento a 1#*En la aritm√©tica de complemento a 1, dos n√∫meros se suman de igual formaque en binario a 1, con la √∫nica diferencia que en caso de existir un √∫ltimoacarreo debe sumarse al resultado.Sumamos los n√∫meros 10 y ‚àí3 en complemento a 1 para n = 8 bitsLa representaci√≥n de los n√∫meros es:Decimal Binario (valor absoluto) Complemento a 1*Decimal:10 Binario (valor absoluto): 00001010 =  Complemento a 1: 00001010Decimal: -3  Binario (valor absoluto):00000011 Complemento a 1: 11111100Por lo tanto la suma:0 0 0 0 1 0 1 0 10(ca1 1 1 1 1 1 1 0 0 ‚àí3(ca1 1 0 0 0 0 0 1 1 0 6(ca1 0 0 0 0 0 0 0 1 1(ca1 ‚Üícarry0 0 0 0 0 1 1 1 7(ca1**Sumamos los n√∫meros 110 y 30 en complemento a 1 para n = 8 bits**0 1 1 0 1 1 1 0 110(ca1
 0 0 0 1 1 1 1 0 30(ca1
1 0 0 0 1 1 0 0 ‚àí115(ca1*Cuando sumamos 110 y 30 en complemento a 1 el resultado que obtenemoses ‚àí113, esto es debido a que la suma entre estos n√∫meros es 140 y est√° fueradel rango posible de representaci√≥n del complemento a 1 de 8 bits. Obtenemoslo que se conoce como sobrecarga u ‚Äúoverflow‚Äù.*#2.3.6. Suma en complemento a 2#En la aritm√©tica de complemento a 2, dos n√∫meros se suman de igual formaque en complemento a 1, con la √∫nica diferencia que se desprecia el √∫ltimoacarreo en el caso que el mismo exista.**Sumamos los n√∫meros 10 y ‚àí3 en complemento a 2 para n = 8 bits**La representaci√≥n de los n√∫meros es:Decimal Binario (valor absoluto) Complemento a 2Decimal: 10  Binario (valor absoluto): 00001010 Complemento a 2: 00001010Decimal: ‚àí3 Binario(valor absoluto): 00000011 Complemento a 2: 11111101Por lo tanto para la suma:0 0 0 0 1 0 1 0 10(ca2 1 1 1 1 1 1 0 1 ‚àí3(ca21 0 0 0 0 0 1 1 1 7(ca2 el acarreo se descarta.Sumamos los n√∫meros 110 y 30 en complemento a 2 para n = 8 bits0 1 1 0 1 1 1 0 110(ca2  0 0 0 1 1 1 1 0 30(ca21 0 0 0 1 1 0 0 ‚àí116(ca2*Cuando sumamos 110 y 30 en complemento a 2 el resultado que obtenemoses ‚àí116, esto es debido a que la suma entre estos n√∫meros es 140 y tambi√©nest√° fuera del rango posible de representaci√≥n del complemento a 2 de 8 bits.Ac√° tambi√©n obtenemos una sobrecarga u ‚Äúoverflow‚Äù.*##2.4. Representaci√≥n en coma o punto fijo##*El nombre de esta representaci√≥n surge de suponer la coma decimal situadaen una posici√≥n fija. El punto fijo es utilizado para la representaci√≥n de n√∫-meros enteros, suponi√©ndose la coma decimal ubicada a la derecha de los bits.Cualquiera de los sistemas de representaci√≥n de enteros vistos en el apartadoanterior es una representaci√≥n de punto fijo, donde por lo general la parte decimales nula. Tambi√©n, el programador puede utilizar la representaci√≥n en puntofijo para representar fracciones binarias escalando los n√∫meros, de modo que lacoma decimal quede ubicada impl√≠citamente en otra posici√≥n entre los bits, yen el caso l√≠mite a la izquierda de todos ellos describiendo un n√∫mero fraccionalbinario puro (menor a 1).*##2.5. Representaci√≥n en coma flotante*La coma o punto flotante surge de la necesidad de representar n√∫meros realesy enteros con un rango de representaci√≥n mayor que el que nos ofrece la representaci√≥nen punto fijo y posibilitar a la computadora el tratamiento de n√∫merosmuy grandes y muy peque√±os. Estas ventajas que nos ofrece la coma flotante traen como contraprestaci√≥n una disminuci√≥n (relativamente peque√±a) en la precisi√≥nde los n√∫meros representados. En su representaci√≥n se utiliza la notaci√≥ncient√≠fica o exponencial matem√°tica en la que una cantidad se representa de lasiguiente forma*:numero = mantisa √ó base exponente (2.12)*Un n√∫mero en esta notaci√≥n cient√≠fica tiene infinitas representaciones, delas que se toma como est√°ndar la denominada normalizada. Consiste en que lamantisa no tiene parte entera y el primer d√≠gito o cifra a la derecha del puntodecimal es significativo, es decir, distinto de 0, salvo en la representaci√≥n deln√∫mero 0.Representemos el n√∫mero 835,4 con base de exponenciaci√≥n 10Con este ejemplo podemos observar c√≥mo se construyen las infinitas representaciones.A nosotros nos va a interesar s√≥lo la representaci√≥n normalizada*.8354 √ó 10‚àí1 = 835, 4 √ó 100 = 83, 54 √ó 101 = 8, 354 √ó 102 = 0, 8354 √ó 103(2.13)*A comienzos de los ¬¥80, cada fabricante de computadoras ten√≠a su propioformato de punto flotante. A fin de rectificar esta situaci√≥n a fines de los ¬¥70 elIEEE (Institute of Electrical and Electronics Engineers, Instituto de IngenierosEl√©ctricos y Electr√≥nicos) form√≥ un comit√© para estandarizar la aritm√©tica depunto flotante. Con esto se podr√≠a no s√≥lo intercambiar los datos de puntoflotante entre diferentes computadoras sino que adem√°s proporcionar√≠a a losdise√±adores de hardware un dise√±o que se sab√≠a correcto. Como resultado elIEEE presenta el est√°ndar internacional de punto flotante, m√°s conocido comoIEEE 754. El est√°ndar define tres formatos, precisi√≥n simple (32 bits), precisi√≥ndoble (64 bits) y precisi√≥n extendida (80 bits). Este √∫ltimo por lo general esutilizado en las unidades aritm√©tico-l√≥gicas de punto flotante, con la intenci√≥nde reducir los errores por redondeo, por lo que s√≥lo nos limitaremos a hablar delos primeros dos formatos.En todos los casos, como la computadora utiliza el sistema binario, la base enla que representaremos el n√∫mero ser√° la base 2. En ambos formatos la palabrabinaria en la que se almacena el n√∫mero en punto flotante se divide en 3 partes.La primera consiste en el signo, la segunda es la representaci√≥n del exponentey por √∫ltimo la representaci√≥n de la fracci√≥n.La definici√≥n del punto flotante de una computadora sigue las siguientesreglas*:

- *El primer bit es utilizado como bit de signo, si este es 0 el signo es positivo(+) y si es 1 el signo es negativo (‚àí), tanto en precisi√≥n simple como enprecisi√≥n doble*.



- *El exponente se representa en exceso a 2n‚àí1, siendo siempre un n√∫meroentero. Para el caso de la precisi√≥n simple el exceso ser√° de 127 y de 1023para la precisi√≥n doble. Los exponentes m√°ximos (255 y 2047) y m√≠nimo(0) se utilizan en casos especiales que describiremos m√°s adelante.*





-  *Los restantes bits representan la fracci√≥n del n√∫mero.*![](http://blogs.ua.es/jpm33/files/2013/06/ieee754_floating_point.gif)**Figura 2.11**: Formato de representaci√≥n IEEE-754 simple y doble precisi√≥n*Una fracci√≥n normalizada comienza con la coma decimal seguida de un biten 1 y luego el resto de la fracci√≥n. Por ejemplo: 0, 10010001010101111101101.Siguiendo una pr√°ctica iniciada en la PDP-11, los autores del est√°ndar se dieroncuenta que el bit inicial de la fracci√≥n no tiene por qu√© almacenarse, ya que puedesimplemente darse por hecho que est√° presente. Por lo tanto la norma definela fracci√≥n de una manera un tanto diferente a lo acostumbrado. La fracci√≥nconsiste en un bit impl√≠cito, seguido de la coma decimal y los siguientes 23 o52 bits correspondientes. De esta manera si los 23 o 52 bits son todos ceros lafracci√≥n representada es el n√∫mero binario 1, 0. Si todos los bits de la fracci√≥nest√°n en uno, la fracci√≥n representa un n√∫mero poco menor que el decimal 2, 0.Por lo general para simplicidad en la lectura, los n√∫meros escritos en estanorma suelen representarse en su equivalente hexadecimal.***2.5.1. Convertimos en IEEE-754 de simple precisi√≥n al n√∫mero ‚àí6, 2734375**Representamos este n√∫mero en punto fijo. Primero tomamos la parte enteray la escribiremos en binario y luego convertiremos la parte decimal como vimosanteriormente:Parte entera: 6(10 = 110(20, 2734375 √ó2 = 0, 5468750, 546875 √ó2 = 1, 093750, 09375 √ó2 = 0, 18750, 1875 √ó2 = 0, 3750, 375 √ó2 = 0, 750, 75 √ó2 = 1, 50, 5 √ó2 = 1, 00, 0 √ó2 = 0Parte decimal: 0, 2734375(10 = 0, 0100011(2Entonces el n√∫mero decimal ‚àí6, 2734375 en binario se escribe ‚àí110, 0100011**Figura 2.12**: Convirtiendo el n√∫mero decimal ‚àí6, 2734375 a binarioUn n√∫mero representado en coma fija, es igual a un n√∫mero expresado ennotaci√≥n cient√≠fica con la base elevada al exponente 0:‚àí6, 2734375 √ó 100 ‚â° ‚àí110, 0100011 √ó 20Ahora que tenemos la notaci√≥n cient√≠fica, hallamos la forma normalizadapara representar en **IEEE-754**:‚àí110, 0100011 √ó 20 = ‚àí11, 00100011 √ó 21 = ‚àí1, 100100011 √ó 22(2.15)Con el n√∫mero normalizado tenemos el valor del exponente que debemoscolocar. En este caso como estamos utilizando precisi√≥n simple, 32 bits, el exponenteutiliza 8 bits por lo tanto el exceso es de 127:127 + 2 = 129(10 = 10000001(2 (2.16)Finalmente escribimos los 32 bits para formar la palabra de precisi√≥n simpleen la norma **IEEE-754**. Como el n√∫mero es negativo, el bit de signo ser√° 1.Luego seguir√°n los 8 bits correspondientes a la representaci√≥n del exponente(10000001) y por √∫ltimo los valores que quedaron detr√°s de la coma decimalen la forma normalizada del n√∫mero en base 2 (100100011) seguidos de 0 paracompletar los √∫ltimos 23 bits.-signo: 1 -exponente: 1000 0001 1001  -mantisa: 0001 1000 0000 0000 000Como mencionamos anteriormente por lo general para simplicidad en lalectura se suele escribir el n√∫mero en **IEEE-754** con sus bytes hexadecimales:1100 0000 1100 1000 1100 0000 0000 0000 =C 0 C 8 C 0 0 0#2.5.2. Casos particularesEn el caso de que el exponente sea todo 0 el n√∫mero representado en lafracci√≥n es un n√∫mero desnormalizado. El cero se representa con el exponenteen 0 y la fracci√≥n tambi√©n en 0. Si tenemos el exponente representando el n√∫merom√°ximo podremos representar en caso de tener la fracci√≥n en 0 a los infinitos. Sitenemos alg√∫n patr√≥n distinto de cero en la fracci√≥n tendremos la representaci√≥nde ‚Äúning√∫n n√∫mero‚Äù o NaN (por sus siglas en ingl√©s, Not a Number).![](http://www.carlospes.com/curso_representacion_datos/imagenes/fig_02_29_de_simple_a_10.gif)![](http://www.carlospes.com/curso_representacion_datos/imagenes/fig_02_30_de_doble_a_10.gif)
*El rango de representaci√≥n en punto flotante debe ser analizado teniendo en
cuenta los m√°ximos y m√≠nimos valores representables tanto con signo positivo
como negativo*:



- m√≠nimo n√∫mero negativo = ‚àí(mantisaMAX) √ó 
base exponente MAX


- m√°ximo n√∫mero negativo = ‚àí(mantisaM IN ) √ó base‚àíexponenteMAX


- m√≠nimo n√∫mero positivo = mantisaM IN √ó base‚àíexponenteMAX

- m√°ximo n√∫mero positivo = mantisaMAX √ó base exponente
![](http://www.portalhuarpe.com.ar/Medhime20/Sitios%20con%20Medhime/Computaci%C3%B3n/COMPUTACION/Menu/modulo%203/imagenes/22figura.GIF)##2.6.1. C√≥digos alfanum√©ricos##*Una computadora puede trabajar internamente con un conjunto de caracteresque nos permitir√°n manejar datos, informaciones, instrucciones, √≥rdenes decontrol, etc. Este conjunto de caracteres podemos subdividirlo en los siguientesgrupos*:

- Caracteres alfab√©ticos

- Letras may√∫sculas (A..Z sin la √ë)

- Letras min√∫sculas (a..z sin la √±)

- Cifras decimales: los n√∫meros 0, 1, ..., 9

- Caracteres especialescaracteres como el . , ; : * @, etc.

- Ordenes de control: Equivalen a las teclas enter, tabulaci√≥n, esc, etc.
*En general cada car√°cter se maneja internamente en una computadora pormedio de un conjunto de 8 bits mediante un sistema de codificaci√≥n binario quedenominaremos c√≥digo de caracteres.Cada computadora tiene su c√≥digo de caracteres definidos por el fabricante,si bien la mayor√≠a de ellos adaptan a sus equipos c√≥digos est√°ndar de los yaestablecidos. En estos c√≥digos se representa cada car√°cter por medio de un byte,con lo cual todo tipo de informaci√≥n puede ser utilizada internamente, formandocadenas de bytes sucesivos que representar√°n cadenas de caracteres para que lam√°quina las maneje e interprete. No todos los tipos de c√≥digos utilizan para larepresentaci√≥n de caracteres los ocho bits de un byte; en la actualidad se tiendea utilizar c√≥digos de 8 bits aunque siguen existiendo algunos c√≥digos de 6 y 7bits*.*El primer c√≥digo alfanum√©rico fue el c√≥digo Baudot de 5 bits (aunque nointerpretado como nosotros lo hacemos ahora) se utilizaba en los teletipos deprincipios del siglo XX. Los primeros c√≥digos utilizados en inform√°tica fueronde 6 bits, que permit√≠an la representaci√≥n de 64 caracteres, que generalmente secorresponden a:*

- 26 letras may√∫sculas

- 10 cifras num√©ricas

- 28 caracteres especiales y de control*Un ejemplo de c√≥digo de 6 bits es el c√≥digo FIELDATA utilizado durante lad√©cada del ¬¥50 por el ej√©rcito de los Estados Unidos. Con el nacimiento de loslenguajes de programaci√≥n de alto nivel comenzaron a utilizarse c√≥digos de 7bits que permiten la representaci√≥n de los mismos caracteres que los c√≥digos de6 bits a√±adiendo las letras min√∫sculas y caracteres cuyo significado son √≥rdenesde control entre perif√©ricos. Un ejemplo muy utilizado de este tipo de c√≥digoses el ASCII (American Standard Code for Information Interchange) de 7 bits.Hoy los c√≥digos utilizados son los de 8 bits, de los cuales los m√°s conocidosson el EBCDIC (Extended Binary Coded Decimal Interchage Code), el ASCIIextendido que agrega un bit a la representaci√≥n extendiendo la cantidad des√≠mbolos disponibles a 256 y el Unicode*.